# equalsをオーバーライドするときは一般契約に従う


`java.lang.Object`のequalsメソッドをオーバーライドするときに **一般契約(general contract)** に従っていないと、バグの温床になる。

---

### `equals`メソッドをオーバーライドしなくても良いケース
- クラスの個々のインスタンスが本質的に一意である
    - `Thread`のように値ではないものを表し、一意であるインスタンス
- クラスが「論理的等価性(logical equality)」の検査を提供する必要がない
    - 例で`java.util.regex.Pattern`が挙がっいる。これは同じ内容を複数の正規表現を用いて表現できているかチェックすることは、プログラマからの需要が少ないかつ作成に工数がかかりメリットが薄いからオーバーロードしなかった説がある。
- スーパークラスがすでに`equals`メソッドをオーバーライドしており、スーパークラスの振る舞いが実装クラスに対して適切な場合
    - 例だと、Set,List,Mapに対するそれぞれのabstractクラスが挙がっている
- クラスが`private`あるいはパッケージプライベートであり、`equals`メソッドが呼び出されないことが確かである。
    - アクセス可能範囲が限られていることから、equalsメソッドの呼び出しが目視でも判断可能なケースを指していると想定している。
    - もし`equals`メソッドが呼ばれたら例外を投げるようにオーバーライドする対策方法もある
    ```
    @Override public boolean equals(Object o) {
        throw new AssertionError();
    }
    ```
---
### そもそもequalsメソッドをオーバーライドしたいときっていつ？
**論理的等価性**を確認したいとき(対となる概念は物理的等価性？）つまり、参照先の値を比較したいときにオーバーライドする必要がある。
Objectクラスのequalsメソッドは参照値比較で等価判定を行うので、参照先の値で比較をするためにオーバーライドをする。

---
 # 一般契約
 - 反射律 (*reflexive*)
    - nullでない任意の参照値*x*に対して、`x.equals(x)`は`true`を返す
 - 対象律 (*symmetric*)
    - nullでない任意の参照値*x、y*に対して、`y.equals(x)`が`true`を返すときのみ`x.equals(y)`は`true`を返す
 - 推移律 (*transitive*)
    - nullでない任意の参照値*x,y,z*に対して、`x.equals(y)`と`y.equals(z)`が`true`を返すとき、`x.equals(z)`は`true`を返す
 - 整合律 (*consistent*)
    - nullでない任意の参照値*x,y*に対して、`x.equals(y)`を複数回呼び出した際に結果が一貫して`true`か`false`を返す
 - 非null性
    - nullでない任意の参照値*x*に対して、`x.equals(null)`は`false`を返す

上記５つの性質のうち、反射律と非null性を破るケースはほとんどないが、
対象律、推移律、整合律は満たされないケースがあり紹介されている。

 ---
## 対象律 (*symmetric*)が満たされないケース
大文字小文字を考慮しない文字列比較のケース
`CaseInsensitiveString`と`String`クラスそれぞれの`equals()`で`Polish`と`polish`を比較した場合。
`CaseInsensitiveString.equals()`では大文字小文字を区別しないでtrueを返すが、`String.equals()`は大文字小文字の区別をするのでfalseを返す。

---
## 推移律 (*transitive*)が満たされないケース
親クラスとフィールドを追加して拡張した子クラスを`equals`で比較した場合
effeの例だと、A=B B=Cは座標部分の(1, 2)部分を比較してtrueを返すがA=Cは色部分が明らかに異なるので推移律を満たさない。
```
A: ColorPont p1 = new ColorPoint(1, 2, Color.RED);
B: Pont p2 = new Point(1, 2);
C: ColorPont p3 = new ColorPoint(1, 2, Color.BLUE);
```
さらに無限再帰を引き起こして、`StackOverflowError`が起こる可能性もある。
補足的に`OutofMemoryError`との違いも調べて、メモリのスタック領域とヒープ領域のどちらでメモリが溢れているかで異なることも学習した。[参照先はこちら](http://www.itsenka.com/contents/development/java/class2.html)

---
### **インスタンス化可能なクラスを継承を使用する限り、equalsの一般契約を満たすことはできない**
さらに、推移律を満たそうとしてinstanceofの代わりにgetClassを用いたときは推移律は満たすが、親クラスの性質を子クラスが引き継ぐべきであるという**リスコフの置換原則**を満たさなくなってしまう。これが満たされないと子クラス継承しているはずの親クラスのメソッドが呼び出せない現象が起こる。

#### 解決策
継承の代わりに**コンポジション**を使用する。具体的には、
- privateフィールドを追加（継承だと子クラスに追加するフィールドに相当する）
- publicのviewメソッドを追加（継承だと親クラスがもっているフィールドのみを返すメソッドに相当する）

#### 補足
- Javaの標準ライブラリでも上記の問題が起きている。（例:`java.util.Date`を拡張した`java.sql.Timestamp`）
- インスタンス化不可能なクラス(例:`abstractクラス`)の継承では推移律が満たされない問題は発生しない。

---
## 整合律 (*consistent*)が満たされないケース
実装側でコントロールできない資源に依存する場合、例ではURLに紐づくIPアドレスの比較が挙げられている。
URLとIPアドレスの対応はN:Nであり、さらにネットワーク接続ができていないとそもそもの比較ができない。

---
## `equals()`メソッドをオーバーライドするときに守るべきこと
1. 引数が自分自身であるか`==`演算子でまず検査する
2. 引数の型チェックは`instanof`演算子で検査する
3. 型チェックを通った変数に対して正しい型へのキャストを行う
4. クラスの「意味のある(*significant*)」（内部実装でのみ使われる変数ではない）フィールドのそれぞれと引数の値が一致するか検査する。
    - チェックの基本は基本データ型は`==`演算子を用いて、オブジェクト参照フィールドは`equals`メソッドを使用。
        - しかし例外として、floatとdoubleはstaticメソッドの`Float.compare(float, float)`か`Double.compare(double, double)`を用いる。
    - オブジェクト参照値として`null`が正当なケースであるときは`NullPointerException`を避けるために`Objects.equals(Object,Object)`で検査する
    - `CaseInsensitiveString`のように複雑な比較のときにはフィールドの *正規形(canonical form)* を保存したほうが性能が良い.特に不変クラスに対しては更新コストがかからなくなるので効果が高い。
    - equalsの評価順番も気にしたほうが良い。短絡評価で実施するので**falseになる可能性が高いかる比較コストが低い**フィールドから先に評価するべき。
---
## 実装例

src/effe/equals/PhoneNumber.java 参照

---

### 注意事項
- equalsをオーバーライドするときは常に`hashCode`もオーバーライドする（項目１１でやる）
- フィールドが等しいかのみチェックする（変にエイリアスやシンボリックリンクまでチェックしようとしない！）
- equalsの引数はObject型以外にしない！（オーバーライドではなくオーバーロードになってしまう）
- googleの`AutoValue`フレームワークを使えばアノテーション１つでequalsメソッドを生成できる。
- IDEの自動生成もあり、人間の実装よりかはミスをしないのでマシ。
    - 実験したが、気をつけないと型チェックにgerClassを使ってリスコフの置換原則を満たさないケースが発生する可能性がある