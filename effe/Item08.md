# ファイナライザとクリーナーを避ける


[**ファイナライザ(*finalizer*)**](https://wa3.i-3-i.info/word13648.html)は一般的に必要ない。Java9からは非推奨となっているがJavaのライブラリではまだ使われている（互換性のため？）
- 理由
    - 不安定な振る舞い
        - 即時実行される保証がないのでインスタンスの破棄が任意の時間遅れる可能性がある
            - 時間的に成約があることを行うべきでないことを意味する 例:ファイルのクローズ
        - ファイナライザはガベージコレクションのアルゴリズム機能なのでJVM実装ごとに振る舞いは大きく異なる
        - **ファイナライズの中でスローされキャッチされなかった例外は無視される**こと
    - 低いパフォーマンス
        - *try-with-resources*よりも約50倍遅い（クリーナーは5倍遅くマシになる）
    - 移植性の問題の原因になる
        - **重大なセキュリティ問題を抱えている**
- **ファイナライザ(*finalizer*)** の補足
    - ガベージコレクタ目線でインスタンスを破棄したときに実行される関数
    - ちなみに**デストラクタ**メソッドはプログラマ目線でインスタンスが破棄されたタイミングで実行されるメソッド
    - ファイナライザのJavadocは[こちら](https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/lang/Object.html#finalize())

---
ファイナライザの代替は[**クリーナー(*cleaner*)**]()であるが、こちらも予測不可能で遅く、一般的に必要ない。

C++に慣れていると、`C++のデストラクタ = Javaのファイナライザとクリーナー`と思うかもしれないが異なるものである。
- 違い
    - 主体がプログラマかガベージコレクタ
    - メモリ以外の資源を回収するか
        - Javaでは*try-with-resources*や*try-finally*ブロックに相当する
---

Javaの言語仕様はファイナライザやクリーナーの即時実行を保証していないので、**永続的な状態の更新をファイナライザやクリーナーでするべきではない**

例： データベースなどの共有された資源に対する永続性のあるロック

---
ho


---
ファイナライザの別の問題は、**ファイナライズの中でスローされキャッチされなかった例外は無視される**こと


---
**重大なセキュリティ問題を抱えている**
- **ファイナライザ攻撃(*finalizer attack*)**
    - 概要
        - `readObject`メソッドや`readResolve`メソッドから例外がスローされると、staticフィールドにオブジェクトの参照を記録できてしまう。
    - 対策
        - 何も行わないfinalの*finalize*メソッドを書く

--- 
### 終了処理を必要とする資源を持っているオブジェクトには何をするべきか？
- **クラスにAutoClosableを実装する**
    - インスタンスが必要なくなって時点で`close`メソッドを呼び出す。
    - 例外発生時に終了処理を保証するために*try-with-resources*を使う。
    - インスタンスがcloseされているのに呼び出されたら**IllegalStateException**をスローする

---
### ファイナライザとクリーナーが役立つ場面
- *close*メソッドの呼び出しを忘れた場合のセーフティネットとなる

- ネイティブピア(*native peer*)を持つオブジェクトに関する
    - ネイティブピアはオブジェクトがネイティブメソッドを通して委譲するネイティブオブジェクト（Javaのオブジェクトではない）ネイティブメソッドは項目66にも記述あり。
    - ガベージコレクタは回収できないのでファイナライザやクリーナーが有効

---
### クリーナーの内容


```
TODO Roomクラス復習で書く

```


